// This is a generated file. Not intended for manual editing.
package com.flipperplz.dayzdev.language.enforce.psi;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import com.flipperplz.dayzdev.language.enforce.psi.impl.*;

public interface EnforceElementTypes {

  IElementType ARITHMETIC_EXPRESSION = new EnforceTokenType("ARITHMETIC_EXPRESSION");
  IElementType ARITHMETIC_OPERATOR = new EnforceTokenType("ARITHMETIC_OPERATOR");
  IElementType ARRAY_INDEX = new EnforceTokenType("ARRAY_INDEX");
  IElementType ARRAY_INDEX_EXPRESSION = new EnforceTokenType("ARRAY_INDEX_EXPRESSION");
  IElementType ASSIGNMENT_EXPRESSION = new EnforceTokenType("ASSIGNMENT_EXPRESSION");
  IElementType ASSIGNMENT_OPERATOR = new EnforceTokenType("ASSIGNMENT_OPERATOR");
  IElementType ATTRIBUTE = new EnforceTokenType("ATTRIBUTE");
  IElementType BLOCK_STATEMENT = new EnforceTokenType("BLOCK_STATEMENT");
  IElementType BREAK_STATEMENT = new EnforceTokenType("BREAK_STATEMENT");
  IElementType CAST_EXPRESSION = new EnforceTokenType("CAST_EXPRESSION");
  IElementType CLASSNAME = new EnforceTokenType("CLASSNAME");
  IElementType CLASS_DECLARATION = new EnforceTokenType("CLASS_DECLARATION");
  IElementType CLASS_EXTENSION = new EnforceTokenType("CLASS_EXTENSION");
  IElementType CLASS_MODIFIER = new EnforceTokenType("CLASS_MODIFIER");
  IElementType CLASS_REFERENCE = new EnforceTokenType("CLASS_REFERENCE");
  IElementType COMPARATIVE_OPERATOR = new EnforceTokenType("COMPARATIVE_OPERATOR");
  IElementType CONTINUE_STATEMENT = new EnforceTokenType("CONTINUE_STATEMENT");
  IElementType DEFAULT_SWITCH_LABEL = new EnforceTokenType("DEFAULT_SWITCH_LABEL");
  IElementType DELETE_STATEMENT = new EnforceTokenType("DELETE_STATEMENT");
  IElementType ELSE_STATEMENT = new EnforceTokenType("ELSE_STATEMENT");
  IElementType ENUM_DECLARATION = new EnforceTokenType("ENUM_DECLARATION");
  IElementType ENUM_VALUE = new EnforceTokenType("ENUM_VALUE");
  IElementType EXPRESSION = new EnforceTokenType("EXPRESSION");
  IElementType FOR_CONTROL = new EnforceTokenType("FOR_CONTROL");
  IElementType FOR_EACH_STATEMENT = new EnforceTokenType("FOR_EACH_STATEMENT");
  IElementType FOR_EACH_VARIABLE = new EnforceTokenType("FOR_EACH_VARIABLE");
  IElementType FOR_STATEMENT = new EnforceTokenType("FOR_STATEMENT");
  IElementType FUNCTION_CALL = new EnforceTokenType("FUNCTION_CALL");
  IElementType FUNCTION_CALL_PARAMETER = new EnforceTokenType("FUNCTION_CALL_PARAMETER");
  IElementType FUNCTION_CALL_PARAMETER_LIST = new EnforceTokenType("FUNCTION_CALL_PARAMETER_LIST");
  IElementType FUNCTION_DECLARATION = new EnforceTokenType("FUNCTION_DECLARATION");
  IElementType FUNCTION_MODIFIER = new EnforceTokenType("FUNCTION_MODIFIER");
  IElementType FUNCTION_NAME = new EnforceTokenType("FUNCTION_NAME");
  IElementType FUNCTION_PARAMETER = new EnforceTokenType("FUNCTION_PARAMETER");
  IElementType FUNCTION_PARAMETER_LIST = new EnforceTokenType("FUNCTION_PARAMETER_LIST");
  IElementType GENERIC_TYPE = new EnforceTokenType("GENERIC_TYPE");
  IElementType GENERIC_TYPE_DECLARATION = new EnforceTokenType("GENERIC_TYPE_DECLARATION");
  IElementType GLOBAL_DECLARATION = new EnforceTokenType("GLOBAL_DECLARATION");
  IElementType GOTO_STATEMENT = new EnforceTokenType("GOTO_STATEMENT");
  IElementType IF_STATEMENT = new EnforceTokenType("IF_STATEMENT");
  IElementType LAMBDA_STATEMENT = new EnforceTokenType("LAMBDA_STATEMENT");
  IElementType LITERAL_ARRAY = new EnforceTokenType("LITERAL_ARRAY");
  IElementType LITERAL_BOOLEAN = new EnforceTokenType("LITERAL_BOOLEAN");
  IElementType LITERAL_FLOAT = new EnforceTokenType("LITERAL_FLOAT");
  IElementType LITERAL_INTEGER = new EnforceTokenType("LITERAL_INTEGER");
  IElementType LITERAL_NULL = new EnforceTokenType("LITERAL_NULL");
  IElementType LITERAL_STRING = new EnforceTokenType("LITERAL_STRING");
  IElementType LOGICAL_EXPRESSION = new EnforceTokenType("LOGICAL_EXPRESSION");
  IElementType LOGICAL_OPERATOR = new EnforceTokenType("LOGICAL_OPERATOR");
  IElementType OBJECT_CREATION_EXPRESSION = new EnforceTokenType("OBJECT_CREATION_EXPRESSION");
  IElementType OPTIONAL_FUNCTION_CALL_PARAM = new EnforceTokenType("OPTIONAL_FUNCTION_CALL_PARAM");
  IElementType PARENTHESISED_EXPRESSION = new EnforceTokenType("PARENTHESISED_EXPRESSION");
  IElementType PRIMARY_EXPRESSION = new EnforceTokenType("PRIMARY_EXPRESSION");
  IElementType RELATIVE_EXPRESSION = new EnforceTokenType("RELATIVE_EXPRESSION");
  IElementType RETURN_STATEMENT = new EnforceTokenType("RETURN_STATEMENT");
  IElementType SEMICOLON_STATEMENT = new EnforceTokenType("SEMICOLON_STATEMENT");
  IElementType STATEMENT = new EnforceTokenType("STATEMENT");
  IElementType SUPER_EXPRESSION = new EnforceTokenType("SUPER_EXPRESSION");
  IElementType SWITCH_BLOCK_STATEMENT_GROUP = new EnforceTokenType("SWITCH_BLOCK_STATEMENT_GROUP");
  IElementType SWITCH_LABEL = new EnforceTokenType("SWITCH_LABEL");
  IElementType SWITCH_STATEMENT = new EnforceTokenType("SWITCH_STATEMENT");
  IElementType THIS_EXPRESSION = new EnforceTokenType("THIS_EXPRESSION");
  IElementType THREAD_STATEMENT = new EnforceTokenType("THREAD_STATEMENT");
  IElementType TYPE_DECLARATION = new EnforceTokenType("TYPE_DECLARATION");
  IElementType TYPE_DECLARATION_LIST = new EnforceTokenType("TYPE_DECLARATION_LIST");
  IElementType TYPE_LIST = new EnforceTokenType("TYPE_LIST");
  IElementType UNARY_PREFIX_EXPRESSION = new EnforceTokenType("UNARY_PREFIX_EXPRESSION");
  IElementType UNARY_PREFIX_OPERATOR = new EnforceTokenType("UNARY_PREFIX_OPERATOR");
  IElementType UNARY_SUFFIX_EXPRESSION = new EnforceTokenType("UNARY_SUFFIX_EXPRESSION");
  IElementType UNARY_SUFFIX_OPERATOR = new EnforceTokenType("UNARY_SUFFIX_OPERATOR");
  IElementType VARIABLE_DECLARATION = new EnforceTokenType("VARIABLE_DECLARATION");
  IElementType VARIABLE_DECLARATOR = new EnforceTokenType("VARIABLE_DECLARATOR");
  IElementType VARIABLE_MODIFIER = new EnforceTokenType("VARIABLE_MODIFIER");
  IElementType VARIABLE_NAME = new EnforceTokenType("VARIABLE_NAME");
  IElementType VAR_AND_FUNCTION_BLOCK = new EnforceTokenType("VAR_AND_FUNCTION_BLOCK");
  IElementType WHILE_STATEMENT = new EnforceTokenType("WHILE_STATEMENT");

  IElementType AUTOPTR = new EnforceTokenType("autoptr");
  IElementType BOOLEAN_LITERAL = new EnforceTokenType("BOOLEAN_LITERAL");
  IElementType BREAK = new EnforceTokenType("break");
  IElementType CLASS = new EnforceTokenType("class");
  IElementType COLON = new EnforceTokenType(":");
  IElementType COMMA = new EnforceTokenType(",");
  IElementType CONST = new EnforceTokenType("const");
  IElementType CONTINUE = new EnforceTokenType("continue");
  IElementType DELETE = new EnforceTokenType("delete");
  IElementType DELIMITED_COMMENT = new EnforceTokenType("DELIMITED_COMMENT");
  IElementType ELSE = new EnforceTokenType("else");
  IElementType EMPTY_DELIMITED_COMMENT = new EnforceTokenType("EMPTY_DELIMITED_COMMENT");
  IElementType ENUM = new EnforceTokenType("enum");
  IElementType EVENT = new EnforceTokenType("event");
  IElementType EXTENDS = new EnforceTokenType("extends");
  IElementType EXTERNAL = new EnforceTokenType("external");
  IElementType FLOAT_LITERAL = new EnforceTokenType("FLOAT_LITERAL");
  IElementType FOR = new EnforceTokenType("for");
  IElementType FOREACH = new EnforceTokenType("foreach");
  IElementType GOTO = new EnforceTokenType("goto");
  IElementType IDENTIFIER = new EnforceTokenType("IDENTIFIER");
  IElementType IF = new EnforceTokenType("if");
  IElementType INOUT = new EnforceTokenType("inout");
  IElementType INTEGER_LITERAL = new EnforceTokenType("INTEGER_LITERAL");
  IElementType LCURLY = new EnforceTokenType("{");
  IElementType LOCAL = new EnforceTokenType("local");
  IElementType LPARENTHESIS = new EnforceTokenType("(");
  IElementType LSBRACKET = new EnforceTokenType("[");
  IElementType MODDED = new EnforceTokenType("modded");
  IElementType NATIVE = new EnforceTokenType("native");
  IElementType NEW = new EnforceTokenType("new");
  IElementType NOTNULL = new EnforceTokenType("notnull");
  IElementType NULL_LITERAL = new EnforceTokenType("NULL_LITERAL");
  IElementType OP_ADD = new EnforceTokenType("+");
  IElementType OP_ADD_ASSIGN = new EnforceTokenType("+=");
  IElementType OP_AND_ASSIGN = new EnforceTokenType("&=");
  IElementType OP_ASSIGN = new EnforceTokenType("=");
  IElementType OP_BANG = new EnforceTokenType("!");
  IElementType OP_BITWISE_AND = new EnforceTokenType("&");
  IElementType OP_BITWISE_NOT = new EnforceTokenType("~");
  IElementType OP_BITWISE_OR = new EnforceTokenType("|");
  IElementType OP_BITWISE_XOR = new EnforceTokenType("^");
  IElementType OP_DECREMENT = new EnforceTokenType("--");
  IElementType OP_DIVIDE = new EnforceTokenType("/");
  IElementType OP_DIVIDE_ASSIGN = new EnforceTokenType("/=");
  IElementType OP_DOT = new EnforceTokenType(".");
  IElementType OP_EQUAL = new EnforceTokenType("==");
  IElementType OP_GREATER = new EnforceTokenType(">");
  IElementType OP_GREATER_EQUAL = new EnforceTokenType(">=");
  IElementType OP_INCREMENT = new EnforceTokenType("++");
  IElementType OP_INEQUAL = new EnforceTokenType("!=");
  IElementType OP_LESS = new EnforceTokenType("<");
  IElementType OP_LESS_EQUAL = new EnforceTokenType("<=");
  IElementType OP_LOGICAL_AND = new EnforceTokenType("&&");
  IElementType OP_LOGICAL_OR = new EnforceTokenType("||");
  IElementType OP_LSHIFT = new EnforceTokenType("<<");
  IElementType OP_LSHIFT_ASSIGN = new EnforceTokenType("<<=");
  IElementType OP_MODULO = new EnforceTokenType("%");
  IElementType OP_MULTIPLY = new EnforceTokenType("*");
  IElementType OP_MULTIPLY_ASSIGN = new EnforceTokenType("*=");
  IElementType OP_OR_ASSIGN = new EnforceTokenType("|=");
  IElementType OP_RSHIFT = new EnforceTokenType(">>");
  IElementType OP_RSHIFT_ASSIGN = new EnforceTokenType(">>=");
  IElementType OP_SUBTRACT = new EnforceTokenType("-");
  IElementType OP_SUBTRACT_ASSIGN = new EnforceTokenType("-=");
  IElementType OP_XOR_ASSIGN = new EnforceTokenType("^=");
  IElementType OUT = new EnforceTokenType("out");
  IElementType OVERRIDE = new EnforceTokenType("override");
  IElementType OWNED = new EnforceTokenType("owned");
  IElementType PRIVATE = new EnforceTokenType("private");
  IElementType PROTECTED = new EnforceTokenType("protected");
  IElementType PROTO = new EnforceTokenType("proto");
  IElementType RCURLY = new EnforceTokenType("}");
  IElementType REF = new EnforceTokenType("ref");
  IElementType REFERENCE = new EnforceTokenType("reference");
  IElementType RETURN = new EnforceTokenType("return");
  IElementType RPARENTHESIS = new EnforceTokenType(")");
  IElementType RSBRACKET = new EnforceTokenType("]");
  IElementType SEALED = new EnforceTokenType("sealed");
  IElementType SEMICOLON = new EnforceTokenType(";");
  IElementType SINGLE_LINE_COMMENT = new EnforceTokenType("SINGLE_LINE_COMMENT");
  IElementType STATIC = new EnforceTokenType("static");
  IElementType STRING_LITERAL = new EnforceTokenType("STRING_LITERAL");
  IElementType SUPER = new EnforceTokenType("super");
  IElementType SWITCH = new EnforceTokenType("switch");
  IElementType THIS = new EnforceTokenType("this");
  IElementType THREAD = new EnforceTokenType("thread");
  IElementType VOLATILE = new EnforceTokenType("volatile");
  IElementType WHILE = new EnforceTokenType("while");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
      if (type == ARITHMETIC_EXPRESSION) {
        return new EsArithmeticExpressionImpl(node);
      }
      else if (type == ARITHMETIC_OPERATOR) {
        return new EsArithmeticOperatorImpl(node);
      }
      else if (type == ARRAY_INDEX) {
        return new EsArrayIndexImpl(node);
      }
      else if (type == ARRAY_INDEX_EXPRESSION) {
        return new EsArrayIndexExpressionImpl(node);
      }
      else if (type == ASSIGNMENT_EXPRESSION) {
        return new EsAssignmentExpressionImpl(node);
      }
      else if (type == ASSIGNMENT_OPERATOR) {
        return new EsAssignmentOperatorImpl(node);
      }
      else if (type == ATTRIBUTE) {
        return new EsAttributeImpl(node);
      }
      else if (type == BLOCK_STATEMENT) {
        return new EsBlockStatementImpl(node);
      }
      else if (type == BREAK_STATEMENT) {
        return new EsBreakStatementImpl(node);
      }
      else if (type == CAST_EXPRESSION) {
        return new EsCastExpressionImpl(node);
      }
      else if (type == CLASSNAME) {
        return new EsClassnameImpl(node);
      }
      else if (type == CLASS_DECLARATION) {
        return new EsClassDeclarationImpl(node);
      }
      else if (type == CLASS_EXTENSION) {
        return new EsClassExtensionImpl(node);
      }
      else if (type == CLASS_MODIFIER) {
        return new EsClassModifierImpl(node);
      }
      else if (type == CLASS_REFERENCE) {
        return new EsClassReferenceImpl(node);
      }
      else if (type == COMPARATIVE_OPERATOR) {
        return new EsComparativeOperatorImpl(node);
      }
      else if (type == CONTINUE_STATEMENT) {
        return new EsContinueStatementImpl(node);
      }
      else if (type == DEFAULT_SWITCH_LABEL) {
        return new EsDefaultSwitchLabelImpl(node);
      }
      else if (type == DELETE_STATEMENT) {
        return new EsDeleteStatementImpl(node);
      }
      else if (type == ELSE_STATEMENT) {
        return new EsElseStatementImpl(node);
      }
      else if (type == ENUM_DECLARATION) {
        return new EsEnumDeclarationImpl(node);
      }
      else if (type == ENUM_VALUE) {
        return new EsEnumValueImpl(node);
      }
      else if (type == FOR_CONTROL) {
        return new EsForControlImpl(node);
      }
      else if (type == FOR_EACH_STATEMENT) {
        return new EsForEachStatementImpl(node);
      }
      else if (type == FOR_EACH_VARIABLE) {
        return new EsForEachVariableImpl(node);
      }
      else if (type == FOR_STATEMENT) {
        return new EsForStatementImpl(node);
      }
      else if (type == FUNCTION_CALL) {
        return new EsFunctionCallImpl(node);
      }
      else if (type == FUNCTION_CALL_PARAMETER) {
        return new EsFunctionCallParameterImpl(node);
      }
      else if (type == FUNCTION_CALL_PARAMETER_LIST) {
        return new EsFunctionCallParameterListImpl(node);
      }
      else if (type == FUNCTION_DECLARATION) {
        return new EsFunctionDeclarationImpl(node);
      }
      else if (type == FUNCTION_MODIFIER) {
        return new EsFunctionModifierImpl(node);
      }
      else if (type == FUNCTION_NAME) {
        return new EsFunctionNameImpl(node);
      }
      else if (type == FUNCTION_PARAMETER) {
        return new EsFunctionParameterImpl(node);
      }
      else if (type == FUNCTION_PARAMETER_LIST) {
        return new EsFunctionParameterListImpl(node);
      }
      else if (type == GENERIC_TYPE) {
        return new EsGenericTypeImpl(node);
      }
      else if (type == GENERIC_TYPE_DECLARATION) {
        return new EsGenericTypeDeclarationImpl(node);
      }
      else if (type == GLOBAL_DECLARATION) {
        return new EsGlobalDeclarationImpl(node);
      }
      else if (type == GOTO_STATEMENT) {
        return new EsGotoStatementImpl(node);
      }
      else if (type == IF_STATEMENT) {
        return new EsIfStatementImpl(node);
      }
      else if (type == LAMBDA_STATEMENT) {
        return new EsLambdaStatementImpl(node);
      }
      else if (type == LITERAL_ARRAY) {
        return new EsLiteralArrayImpl(node);
      }
      else if (type == LITERAL_BOOLEAN) {
        return new EsLiteralBooleanImpl(node);
      }
      else if (type == LITERAL_FLOAT) {
        return new EsLiteralFloatImpl(node);
      }
      else if (type == LITERAL_INTEGER) {
        return new EsLiteralIntegerImpl(node);
      }
      else if (type == LITERAL_NULL) {
        return new EsLiteralNullImpl(node);
      }
      else if (type == LITERAL_STRING) {
        return new EsLiteralStringImpl(node);
      }
      else if (type == LOGICAL_EXPRESSION) {
        return new EsLogicalExpressionImpl(node);
      }
      else if (type == LOGICAL_OPERATOR) {
        return new EsLogicalOperatorImpl(node);
      }
      else if (type == OBJECT_CREATION_EXPRESSION) {
        return new EsObjectCreationExpressionImpl(node);
      }
      else if (type == OPTIONAL_FUNCTION_CALL_PARAM) {
        return new EsOptionalFunctionCallParamImpl(node);
      }
      else if (type == PARENTHESISED_EXPRESSION) {
        return new EsParenthesisedExpressionImpl(node);
      }
      else if (type == PRIMARY_EXPRESSION) {
        return new EsPrimaryExpressionImpl(node);
      }
      else if (type == RELATIVE_EXPRESSION) {
        return new EsRelativeExpressionImpl(node);
      }
      else if (type == RETURN_STATEMENT) {
        return new EsReturnStatementImpl(node);
      }
      else if (type == SEMICOLON_STATEMENT) {
        return new EsSemicolonStatementImpl(node);
      }
      else if (type == STATEMENT) {
        return new EsStatementImpl(node);
      }
      else if (type == SUPER_EXPRESSION) {
        return new EsSuperExpressionImpl(node);
      }
      else if (type == SWITCH_BLOCK_STATEMENT_GROUP) {
        return new EsSwitchBlockStatementGroupImpl(node);
      }
      else if (type == SWITCH_LABEL) {
        return new EsSwitchLabelImpl(node);
      }
      else if (type == SWITCH_STATEMENT) {
        return new EsSwitchStatementImpl(node);
      }
      else if (type == THIS_EXPRESSION) {
        return new EsThisExpressionImpl(node);
      }
      else if (type == THREAD_STATEMENT) {
        return new EsThreadStatementImpl(node);
      }
      else if (type == TYPE_DECLARATION) {
        return new EsTypeDeclarationImpl(node);
      }
      else if (type == TYPE_DECLARATION_LIST) {
        return new EsTypeDeclarationListImpl(node);
      }
      else if (type == TYPE_LIST) {
        return new EsTypeListImpl(node);
      }
      else if (type == UNARY_PREFIX_EXPRESSION) {
        return new EsUnaryPrefixExpressionImpl(node);
      }
      else if (type == UNARY_PREFIX_OPERATOR) {
        return new EsUnaryPrefixOperatorImpl(node);
      }
      else if (type == UNARY_SUFFIX_EXPRESSION) {
        return new EsUnarySuffixExpressionImpl(node);
      }
      else if (type == UNARY_SUFFIX_OPERATOR) {
        return new EsUnarySuffixOperatorImpl(node);
      }
      else if (type == VARIABLE_DECLARATION) {
        return new EsVariableDeclarationImpl(node);
      }
      else if (type == VARIABLE_DECLARATOR) {
        return new EsVariableDeclaratorImpl(node);
      }
      else if (type == VARIABLE_MODIFIER) {
        return new EsVariableModifierImpl(node);
      }
      else if (type == VARIABLE_NAME) {
        return new EsVariableNameImpl(node);
      }
      else if (type == VAR_AND_FUNCTION_BLOCK) {
        return new EsVarAndFunctionBlockImpl(node);
      }
      else if (type == WHILE_STATEMENT) {
        return new EsWhileStatementImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
